import { ParsedAPI, ParsedEndpoint, ParsedParameter } from './openapi-types';

export class TypeScriptAPIClientGenerator {
  generate(api: ParsedAPI, sourceFile: string): string {
    const lines: string[] = [];

    // Header
    lines.push(this.createHeader(sourceFile));
    lines.push('');

    // Configuration interface
    lines.push('export interface APIClientConfig {');
    lines.push('  baseURL: string;');
    lines.push('  headers?: Record<string, string>;');
    lines.push('  fetch?: typeof fetch;');
    lines.push('}');
    lines.push('');

    // API Client class
    if (api.description) {
      lines.push(`/**`);
      lines.push(` * ${api.description}`);
      lines.push(` */`);
    }
    lines.push(`export class ${api.name}APIClient {`);
    lines.push('  private baseURL: string;');
    lines.push('  private headers: Record<string, string>;');
    lines.push('  private fetchFn: typeof fetch;');
    lines.push('');
    lines.push('  constructor(config: APIClientConfig) {');
    lines.push('    this.baseURL = config.baseURL;');
    lines.push('    this.headers = config.headers || {};');
    lines.push('    this.fetchFn = config.fetch || fetch;');
    lines.push('  }');
    lines.push('');

    // Method implementations
    api.endpoints.forEach(endpoint => {
      lines.push(this.generateMethod(endpoint));
      lines.push('');
    });

    // Helper methods
    lines.push(this.generateHelperMethods());

    lines.push('}');
    lines.push('');

    // Error class
    lines.push(this.generateErrorClass(api.name));
    lines.push('');

    // Response types
    lines.push(this.generateResponseTypes(api.endpoints));

    return lines.join('\n');
  }

  private createHeader(sourceFile: string): string {
    const timestamp = new Date().toISOString().split('T')[0];
    return [
      `// Generated by cuppa-cli from ${sourceFile}`,
      `// Generation date: ${timestamp}`,
      `// DO NOT EDIT MANUALLY - Changes will be overwritten`,
      '',
    ].join('\n');
  }

  private generateMethod(endpoint: ParsedEndpoint): string {
    const lines: string[] = [];

    // Documentation
    if (endpoint.summary || endpoint.description) {
      lines.push('  /**');
      if (endpoint.summary) {
        lines.push(`   * ${endpoint.summary}`);
      }
      if (endpoint.description) {
        lines.push(`   * ${endpoint.description}`);
      }

      // Parameters documentation
      const allParams = [...endpoint.pathParams, ...endpoint.queryParams];
      if (endpoint.requestBody) {
        allParams.push({
          name: 'body',
          type: endpoint.requestBody.type,
          description: endpoint.requestBody.description,
          required: endpoint.requestBody.required,
          isArray: false,
        });
      }

      allParams.forEach(param => {
        const desc = param.description || param.name;
        lines.push(`   * @param ${param.name} ${desc}`);
      });

      lines.push('   */');
    }

    // Method signature
    const params = this.buildParameters(endpoint);
    const responseType = this.getResponseType(endpoint);
    lines.push(`  async ${endpoint.operationId}(${params}): Promise<${responseType}> {`);

    // Build URL
    lines.push('    // Build URL');
    let urlPath = endpoint.path;
    endpoint.pathParams.forEach(param => {
      urlPath = urlPath.replace(`{${param.name}}`, `\${${param.name}}`);
    });
    lines.push(`    let url = \`\${this.baseURL}${urlPath}\`;`);

    // Add query parameters
    if (endpoint.queryParams.length > 0) {
      lines.push('');
      lines.push('    // Add query parameters');
      lines.push('    const queryParams = new URLSearchParams();');
      endpoint.queryParams.forEach(param => {
        if (param.required) {
          lines.push(`    queryParams.append('${param.name}', String(${param.name}));`);
        } else {
          lines.push(`    if (${param.name} !== undefined && ${param.name} !== null) {`);
          lines.push(`      queryParams.append('${param.name}', String(${param.name}));`);
          lines.push('    }');
        }
      });
      lines.push('    const queryString = queryParams.toString();');
      lines.push('    if (queryString) {');
      lines.push('      url += `?${queryString}`;');
      lines.push('    }');
    }

    lines.push('');
    lines.push('    // Build request options');
    lines.push('    const options: RequestInit = {');
    lines.push(`      method: '${endpoint.method}',`);
    lines.push('      headers: {');
    lines.push('        \'Content-Type\': \'application/json\',');
    lines.push('        ...this.headers,');
    lines.push('      },');

    // Add request body
    if (endpoint.requestBody) {
      lines.push('      body: JSON.stringify(body),');
    }

    lines.push('    };');
    lines.push('');

    // Execute request
    lines.push('    // Execute request');
    lines.push('    const response = await this.fetchFn(url, options);');
    lines.push('');
    lines.push('    if (!response.ok) {');
    lines.push('      const errorText = await response.text();');
    lines.push('      throw new APIError(');
    lines.push('        `HTTP ${response.status}: ${errorText}`,');
    lines.push('        response.status,');
    lines.push('        errorText');
    lines.push('      );');
    lines.push('    }');

    // Decode response
    const successResponse = endpoint.responses.find(r => r.statusCode.startsWith('2'));
    if (successResponse && successResponse.type) {
      lines.push('');
      lines.push('    // Parse response');
      lines.push('    return await response.json();');
    } else {
      lines.push('');
      lines.push('    return;');
    }

    lines.push('  }');

    return lines.join('\n');
  }

  private generateHelperMethods(): string {
    return [
      '  /**',
      '   * Set default headers for all requests',
      '   */',
      '  setHeaders(headers: Record<string, string>): void {',
      '    this.headers = { ...this.headers, ...headers };',
      '  }',
      '',
      '  /**',
      '   * Set authorization header',
      '   */',
      '  setAuthToken(token: string): void {',
      '    this.headers.Authorization = `Bearer ${token}`;',
      '  }',
    ].join('\n');
  }

  private generateErrorClass(apiName: string): string {
    return [
      `/**`,
      ` * Error class for ${apiName} API client`,
      ` */`,
      'export class APIError extends Error {',
      '  constructor(',
      '    message: string,',
      '    public statusCode?: number,',
      '    public responseBody?: string',
      '  ) {',
      '    super(message);',
      '    this.name = \'APIError\';',
      '  }',
      '}',
    ].join('\n');
  }

  private generateResponseTypes(endpoints: ParsedEndpoint[]): string {
    const lines: string[] = [];

    lines.push('// Request/Response type definitions');
    lines.push('// Import or define your model types here');

    return lines.join('\n');
  }

  private buildParameters(endpoint: ParsedEndpoint): string {
    const allParams = [...endpoint.pathParams, ...endpoint.queryParams];
    if (endpoint.requestBody) {
      allParams.push({
        name: 'body',
        type: endpoint.requestBody.type,
        description: endpoint.requestBody.description,
        required: endpoint.requestBody.required,
        isArray: false,
      });
    }

    if (allParams.length === 0) {
      return '';
    }

    // Group into a params object for better API
    const paramList = allParams.map(p => {
      const type = this.mapToTypeScriptType(p.type, p.isArray);
      const optional = p.required ? '' : '?';
      return `${p.name}${optional}: ${type}`;
    });

    return `{ ${paramList.join(', ')} }`;
  }

  private getResponseType(endpoint: ParsedEndpoint): string {
    const successResponse = endpoint.responses.find(r => r.statusCode.startsWith('2'));
    if (successResponse && successResponse.type) {
      const isArray = successResponse.type.startsWith('array');
      return this.mapToTypeScriptType(successResponse.type, isArray);
    }
    return 'void';
  }

  private mapToTypeScriptType(type: string, isArray: boolean = false): string {
    let baseType = this.getBaseTypeScriptType(type);

    if (isArray) {
      baseType = `${baseType}[]`;
    }

    return baseType;
  }

  private getBaseTypeScriptType(type: string): string {
    switch (type) {
      case 'string':
        return 'string';
      case 'integer':
      case 'number':
        return 'number';
      case 'boolean':
        return 'boolean';
      case 'object':
        return 'Record<string, unknown>';
      case 'array':
        return 'unknown[]';
      default:
        // Assume it's a model reference
        return type;
    }
  }
}
