import { ParsedModel, ParsedProperty } from './json-schema-types';

export class TypeScriptModelGenerator {
  generate(model: ParsedModel, sourceFile: string): string {
    const lines: string[] = [];

    // Header
    lines.push(this.createHeader(sourceFile));
    lines.push('');

    // Documentation
    if (model.description) {
      lines.push(`/**`);
      lines.push(` * ${model.description}`);
      lines.push(` */`);
    }

    // Interface declaration
    lines.push(`export interface ${model.name} {`);

    // Properties
    model.properties.forEach(prop => {
      lines.push(this.generateProperty(prop));
    });

    lines.push('}');
    lines.push('');

    // Runtime validation helper (optional)
    lines.push(this.generateValidator(model));

    return lines.join('\n');
  }

  private createHeader(sourceFile: string): string {
    const timestamp = new Date().toISOString().split('T')[0];
    return [
      `// Generated by cuppa-cli from ${sourceFile}`,
      `// Generation date: ${timestamp}`,
      `// DO NOT EDIT MANUALLY - Changes will be overwritten`,
      '',
    ].join('\n');
  }

  private generateProperty(prop: ParsedProperty): string {
    const lines: string[] = [];

    // Documentation
    if (prop.description) {
      lines.push(`  /** ${prop.description} */`);
    }

    // Property declaration
    const tsType = this.mapToTypeScriptType(prop);
    const optional = prop.optional ? '?' : '';
    lines.push(`  ${prop.name}${optional}: ${tsType};`);

    return lines.join('\n');
  }

  private generateValidator(model: ParsedModel): string {
    const lines: string[] = [];

    lines.push(`/**`);
    lines.push(` * Type guard to validate ${model.name} at runtime`);
    lines.push(` */`);
    lines.push(`export function is${model.name}(obj: unknown): obj is ${model.name} {`);
    lines.push(`  if (typeof obj !== 'object' || obj === null) {`);
    lines.push(`    return false;`);
    lines.push(`  }`);
    lines.push('');
    lines.push(`  const data = obj as Record<string, unknown>;`);
    lines.push('');

    // Check required properties
    const requiredProps = model.properties.filter(p => !p.optional);
    if (requiredProps.length > 0) {
      lines.push(`  // Check required properties`);
      requiredProps.forEach(prop => {
        const check = this.generateTypeCheck(prop);
        lines.push(`  if (${check}) return false;`);
      });
      lines.push('');
    }

    lines.push(`  return true;`);
    lines.push(`}`);
    lines.push('');

    return lines.join('\n');
  }

  private generateTypeCheck(prop: ParsedProperty): string {
    const accessor = `data.${prop.name}`;

    if (prop.isArray) {
      return `!Array.isArray(${accessor})`;
    }

    switch (prop.type) {
      case 'string':
        return `typeof ${accessor} !== 'string'`;
      case 'integer':
      case 'number':
        return `typeof ${accessor} !== 'number'`;
      case 'boolean':
        return `typeof ${accessor} !== 'boolean'`;
      case 'object':
        return `typeof ${accessor} !== 'object' || ${accessor} === null`;
      default:
        return `${accessor} === undefined`;
    }
  }

  private mapToTypeScriptType(prop: ParsedProperty): string {
    let baseType = this.getBaseTypeScriptType(prop.type, prop.format);

    if (prop.isArray) {
      baseType = `${baseType}[]`;
    }

    if (prop.optional) {
      baseType = `${baseType} | null`;
    }

    return baseType;
  }

  private getBaseTypeScriptType(type: string, format?: string): string {
    // Handle format-specific types
    if (format) {
      switch (format) {
        case 'uuid':
          return 'string'; // Could use a branded type
        case 'date':
        case 'date-time':
          return 'string'; // or Date if you prefer runtime Date objects
        case 'uri':
        case 'url':
          return 'string';
        case 'email':
          return 'string';
      }
    }

    // Handle basic types
    switch (type) {
      case 'string':
        return 'string';
      case 'integer':
      case 'number':
        return 'number';
      case 'boolean':
        return 'boolean';
      case 'object':
        return 'Record<string, unknown>';
      case 'array':
        return 'unknown[]';
      default:
        return 'unknown'; // Fallback
    }
  }
}
