import { ParsedModel, ParsedProperty } from './json-schema-types';

export class SwiftModelGenerator {
  generate(model: ParsedModel, sourceFile: string): string {
    const lines: string[] = [];

    // Header
    lines.push(this.createHeader(sourceFile));
    lines.push('import Foundation');
    lines.push('');

    // Documentation
    if (model.description) {
      lines.push(`/// ${model.description}`);
    }

    // Struct declaration
    lines.push(`public struct ${model.name}: Codable, Identifiable, Sendable {`);

    // Properties
    model.properties.forEach(prop => {
      lines.push(this.generateProperty(prop));
    });

    lines.push('');

    // Initializer
    lines.push(this.generateInitializer(model));

    // Closing brace
    lines.push('}');
    lines.push('');

    return lines.join('\n');
  }

  private createHeader(sourceFile: string): string {
    const timestamp = new Date().toISOString().split('T')[0];
    return [
      `// Generated by cuppa-cli from ${sourceFile}`,
      `// Generation date: ${timestamp}`,
      `// DO NOT EDIT MANUALLY - Changes will be overwritten`,
      '',
    ].join('\n');
  }

  private generateProperty(prop: ParsedProperty): string {
    const lines: string[] = [];

    // Documentation
    if (prop.description) {
      lines.push(`    /// ${prop.description}`);
    }

    // Property declaration
    const swiftType = this.mapToSwiftType(prop);
    const keyword = prop.name === 'id' ? 'let' : 'let'; // In Swift, all properties are let for value types
    lines.push(`    public ${keyword} ${prop.name}: ${swiftType}`);

    return lines.join('\n');
  }

  private generateInitializer(model: ParsedModel): string {
    const lines: string[] = [];

    lines.push('    public init(');

    // Parameters
    const params = model.properties.map((prop, index) => {
      const swiftType = this.mapToSwiftType(prop);
      const isLast = index === model.properties.length - 1;
      const defaultValue = prop.optional ? ' = nil' : '';
      return `        ${prop.name}: ${swiftType}${defaultValue}${isLast ? '' : ','}`;
    });

    lines.push(...params);
    lines.push('    ) {');

    // Assignments
    model.properties.forEach(prop => {
      lines.push(`        self.${prop.name} = ${prop.name}`);
    });

    lines.push('    }');

    return lines.join('\n');
  }

  private mapToSwiftType(prop: ParsedProperty): string {
    let baseType = this.getBaseSwiftType(prop.type, prop.format);

    if (prop.isArray) {
      baseType = `[${baseType}]`;
    }

    if (prop.optional) {
      baseType = `${baseType}?`;
    }

    return baseType;
  }

  private getBaseSwiftType(type: string, format?: string): string {
    // Handle format-specific types
    if (format) {
      switch (format) {
        case 'uuid':
          return 'String'; // or UUID if you prefer
        case 'date':
          return 'Date';
        case 'date-time':
          return 'Date';
        case 'uri':
        case 'url':
          return 'String'; // or URL
        case 'email':
          return 'String';
      }
    }

    // Handle basic types
    switch (type) {
      case 'string':
        return 'String';
      case 'integer':
        return 'Int';
      case 'number':
        return 'Double';
      case 'boolean':
        return 'Bool';
      case 'object':
        return '[String: Any]'; // Generic object
      case 'array':
        return '[Any]';
      default:
        return 'String'; // Fallback
    }
  }
}
