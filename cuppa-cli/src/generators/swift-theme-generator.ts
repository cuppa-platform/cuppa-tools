import { ParsedTheme } from './design-tokens-types';

export class SwiftThemeGenerator {
  generate(theme: ParsedTheme, sourceFile: string): string {
    const lines: string[] = [];

    // Header
    lines.push(this.createHeader(sourceFile));
    lines.push('import SwiftUI');
    lines.push('');

    // Theme struct
    lines.push(`/// Design system theme generated from ${sourceFile}`);
    lines.push(`public struct ${theme.name} {`);
    lines.push('    private init() {}');
    lines.push('');

    // Colors
    if (theme.colors.length > 0) {
      lines.push('    // MARK: - Colors');
      lines.push('    public enum Colors {');
      theme.colors.forEach(color => {
        if (color.description) {
          lines.push(`        /// ${color.description}`);
        }
        const swiftColor = this.convertToSwiftColor(color.value);
        lines.push(`        public static let ${color.name} = ${swiftColor}`);
      });
      lines.push('    }');
      lines.push('');
    }

    // Typography
    if (this.hasTypography(theme)) {
      lines.push('    // MARK: - Typography');

      // Font Families
      if (theme.typography.fontFamilies.length > 0) {
        lines.push('    public enum FontFamilies {');
        theme.typography.fontFamilies.forEach(font => {
          lines.push(`        public static let ${font.name} = "${font.value}"`);
        });
        lines.push('    }');
        lines.push('');
      }

      // Font Sizes
      if (theme.typography.fontSizes.length > 0) {
        lines.push('    public enum FontSizes {');
        theme.typography.fontSizes.forEach(size => {
          lines.push(`        public static let ${size.name}: CGFloat = ${size.value}`);
        });
        lines.push('    }');
        lines.push('');
      }

      // Font Weights
      if (theme.typography.fontWeights.length > 0) {
        lines.push('    public enum FontWeights {');
        theme.typography.fontWeights.forEach(weight => {
          const swiftWeight = this.convertToSwiftFontWeight(weight.value);
          lines.push(`        public static let ${weight.name} = ${swiftWeight}`);
        });
        lines.push('    }');
        lines.push('');
      }
    }

    // Spacing
    if (theme.spacing.length > 0) {
      lines.push('    // MARK: - Spacing');
      lines.push('    public enum Spacing {');
      theme.spacing.forEach(space => {
        lines.push(`        public static let ${space.name}: CGFloat = ${space.value}`);
      });
      lines.push('    }');
      lines.push('');
    }

    // Border Radius
    if (theme.borderRadius.length > 0) {
      lines.push('    // MARK: - Border Radius');
      lines.push('    public enum BorderRadius {');
      theme.borderRadius.forEach(radius => {
        lines.push(`        public static let ${radius.name}: CGFloat = ${radius.value}`);
      });
      lines.push('    }');
      lines.push('');
    }

    // Shadows
    if (theme.shadows.length > 0) {
      lines.push('    // MARK: - Shadows');
      lines.push('    public enum Shadows {');
      theme.shadows.forEach(shadow => {
        if (shadow.description) {
          lines.push(`        /// ${shadow.description}`);
        }
        lines.push(`        public static let ${shadow.name} = "${shadow.value}"`);
      });
      lines.push('    }');
      lines.push('');
    }

    lines.push('}');
    lines.push('');

    // SwiftUI Extensions
    lines.push('// MARK: - SwiftUI Extensions');
    lines.push('');
    lines.push('public extension Color {');
    theme.colors.forEach(color => {
      const swiftColor = this.convertToSwiftColor(color.value);
      lines.push(`    static let ${color.name} = ${swiftColor}`);
    });
    lines.push('}');
    lines.push('');

    // Font extension
    if (theme.typography.fontSizes.length > 0) {
      lines.push('public extension Font {');
      theme.typography.fontFamilies.forEach(family => {
        theme.typography.fontSizes.forEach(size => {
          const methodName = `${family.name}${this.capitalize(size.name)}`;
          lines.push(`    static func ${methodName}() -> Font {`);
          lines.push(`        return .custom(${theme.name}.FontFamilies.${family.name}, size: ${theme.name}.FontSizes.${size.name})`);
          lines.push('    }');
        });
      });
      lines.push('}');
      lines.push('');
    }

    return lines.join('\n');
  }

  private createHeader(sourceFile: string): string {
    const timestamp = new Date().toISOString().split('T')[0];
    return [
      `// Generated by cuppa-cli from ${sourceFile}`,
      `// Generation date: ${timestamp}`,
      `// DO NOT EDIT MANUALLY - Changes will be overwritten`,
      '',
    ].join('\n');
  }

  private hasTypography(theme: ParsedTheme): boolean {
    return (
      theme.typography.fontFamilies.length > 0 ||
      theme.typography.fontSizes.length > 0 ||
      theme.typography.fontWeights.length > 0
    );
  }

  private convertToSwiftColor(hexColor: string): string {
    // Remove # if present
    const hex = hexColor.replace('#', '');

    if (hex.length === 6) {
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);

      return `Color(red: ${r}/255, green: ${g}/255, blue: ${b}/255)`;
    } else if (hex.length === 8) {
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);
      const a = parseInt(hex.substring(6, 8), 16);

      return `Color(red: ${r}/255, green: ${g}/255, blue: ${b}/255, opacity: ${a}/255)`;
    }

    // Fallback
    return `Color(hex: "${hexColor}")`;
  }

  private convertToSwiftFontWeight(weight: string | number): string {
    if (typeof weight === 'number') {
      // Map numeric weights to Swift font weights
      if (weight <= 200) return 'Font.Weight.ultraLight';
      if (weight <= 300) return 'Font.Weight.light';
      if (weight <= 400) return 'Font.Weight.regular';
      if (weight <= 500) return 'Font.Weight.medium';
      if (weight <= 600) return 'Font.Weight.semibold';
      if (weight <= 700) return 'Font.Weight.bold';
      if (weight <= 800) return 'Font.Weight.heavy';
      return 'Font.Weight.black';
    }

    // Map string weights
    const weightMap: Record<string, string> = {
      thin: 'Font.Weight.ultraLight',
      extralight: 'Font.Weight.ultraLight',
      light: 'Font.Weight.light',
      normal: 'Font.Weight.regular',
      regular: 'Font.Weight.regular',
      medium: 'Font.Weight.medium',
      semibold: 'Font.Weight.semibold',
      bold: 'Font.Weight.bold',
      extrabold: 'Font.Weight.heavy',
      heavy: 'Font.Weight.heavy',
      black: 'Font.Weight.black',
    };

    return weightMap[weight.toLowerCase()] || 'Font.Weight.regular';
  }

  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}
