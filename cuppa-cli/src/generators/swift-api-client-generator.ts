import { ParsedAPI, ParsedEndpoint, ParsedParameter } from './openapi-types';

export class SwiftAPIClientGenerator {
  generate(api: ParsedAPI, sourceFile: string): string {
    const lines: string[] = [];

    // Header
    lines.push(this.createHeader(sourceFile));
    lines.push('import Foundation');
    lines.push('');

    // API Client Protocol
    if (api.description) {
      lines.push(`/// ${api.description}`);
    }
    lines.push(`public protocol ${api.name}APIClient {`);

    // Method declarations
    api.endpoints.forEach(endpoint => {
      lines.push(this.generateMethodSignature(endpoint));
    });

    lines.push('}');
    lines.push('');

    // Default implementation
    lines.push(`/// Default implementation of ${api.name}APIClient`);
    lines.push(`public class Default${api.name}APIClient: ${api.name}APIClient {`);
    lines.push('    private let baseURL: URL');
    lines.push('    private let session: URLSession');
    lines.push('');
    lines.push('    public init(baseURL: URL, session: URLSession = .shared) {');
    lines.push('        self.baseURL = baseURL');
    lines.push('        self.session = session');
    lines.push('    }');
    lines.push('');

    // Method implementations
    api.endpoints.forEach(endpoint => {
      lines.push(this.generateMethodImplementation(endpoint));
      lines.push('');
    });

    lines.push('}');
    lines.push('');

    // Error enum
    lines.push(this.generateErrorEnum(api.name));

    return lines.join('\n');
  }

  private createHeader(sourceFile: string): string {
    const timestamp = new Date().toISOString().split('T')[0];
    return [
      `// Generated by cuppa-cli from ${sourceFile}`,
      `// Generation date: ${timestamp}`,
      `// DO NOT EDIT MANUALLY - Changes will be overwritten`,
      '',
    ].join('\n');
  }

  private generateMethodSignature(endpoint: ParsedEndpoint): string {
    const lines: string[] = [];

    // Documentation
    if (endpoint.summary) {
      lines.push(`    /// ${endpoint.summary}`);
    }
    if (endpoint.description) {
      lines.push(`    /// ${endpoint.description}`);
    }

    // Parameters documentation
    const allParams = [...endpoint.pathParams, ...endpoint.queryParams];
    if (endpoint.requestBody) {
      allParams.push({
        name: 'body',
        type: endpoint.requestBody.type,
        description: endpoint.requestBody.description,
        required: endpoint.requestBody.required,
        isArray: false,
      });
    }

    allParams.forEach(param => {
      const desc = param.description || param.name;
      lines.push(`    /// - Parameter ${param.name}: ${desc}`);
    });

    // Method signature
    const params = allParams.map(p => {
      const type = this.mapToSwiftType(p.type, p.isArray);
      const optional = p.required ? '' : '?';
      return `${p.name}: ${type}${optional}`;
    });

    const responseType = this.getResponseType(endpoint);
    const signature = `    func ${endpoint.operationId}(${params.join(', ')}) async throws -> ${responseType}`;
    lines.push(signature);

    return lines.join('\n');
  }

  private generateMethodImplementation(endpoint: ParsedEndpoint): string {
    const lines: string[] = [];

    // Method signature
    const allParams = [...endpoint.pathParams, ...endpoint.queryParams];
    if (endpoint.requestBody) {
      allParams.push({
        name: 'body',
        type: endpoint.requestBody.type,
        description: endpoint.requestBody.description,
        required: endpoint.requestBody.required,
        isArray: false,
      });
    }

    const params = allParams.map(p => {
      const type = this.mapToSwiftType(p.type, p.isArray);
      const optional = p.required ? '' : '?';
      return `${p.name}: ${type}${optional}`;
    });

    const responseType = this.getResponseType(endpoint);
    lines.push(`    public func ${endpoint.operationId}(${params.join(', ')}) async throws -> ${responseType} {`);

    // Build URL
    lines.push(`        // Build URL`);
    let urlPath = endpoint.path;
    endpoint.pathParams.forEach(param => {
      urlPath = urlPath.replace(`{${param.name}}`, `\\(${param.name})`);
    });
    lines.push(`        var urlString = baseURL.appendingPathComponent("${urlPath}").absoluteString`);

    // Add query parameters
    if (endpoint.queryParams.length > 0) {
      lines.push('');
      lines.push('        // Add query parameters');
      lines.push('        var components = URLComponents(string: urlString)!');
      lines.push('        var queryItems: [URLQueryItem] = []');
      endpoint.queryParams.forEach(param => {
        if (param.required) {
          lines.push(`        queryItems.append(URLQueryItem(name: "${param.name}", value: "\\(${param.name})"))`);
        } else {
          lines.push(`        if let ${param.name} = ${param.name} {`);
          lines.push(`            queryItems.append(URLQueryItem(name: "${param.name}", value: "\\(${param.name})"))`);
          lines.push('        }');
        }
      });
      lines.push('        components.queryItems = queryItems');
      lines.push('        urlString = components.url!.absoluteString');
    }

    lines.push('');
    lines.push('        guard let url = URL(string: urlString) else {');
    lines.push(`            throw ${this.getErrorTypeName(endpoint)}Error.invalidURL`);
    lines.push('        }');
    lines.push('');

    // Build request
    lines.push('        // Build request');
    lines.push('        var request = URLRequest(url: url)');
    lines.push(`        request.httpMethod = "${endpoint.method}"`);

    // Add request body
    if (endpoint.requestBody) {
      lines.push('');
      lines.push('        // Encode request body');
      lines.push('        let encoder = JSONEncoder()');
      lines.push('        request.httpBody = try encoder.encode(body)');
      lines.push('        request.setValue("application/json", forHTTPHeaderField: "Content-Type")');
    }

    lines.push('');
    lines.push('        // Execute request');
    lines.push('        let (data, response) = try await session.data(for: request)');
    lines.push('');
    lines.push('        guard let httpResponse = response as? HTTPURLResponse else {');
    lines.push(`            throw ${this.getErrorTypeName(endpoint)}Error.invalidResponse`);
    lines.push('        }');
    lines.push('');
    lines.push('        guard (200...299).contains(httpResponse.statusCode) else {');
    lines.push(`            throw ${this.getErrorTypeName(endpoint)}Error.httpError(httpResponse.statusCode)`);
    lines.push('        }');

    // Decode response
    const successResponse = endpoint.responses.find(r => r.statusCode.startsWith('2'));
    if (successResponse && successResponse.type) {
      lines.push('');
      lines.push('        // Decode response');
      lines.push('        let decoder = JSONDecoder()');
      lines.push(`        return try decoder.decode(${responseType}.self, from: data)`);
    } else {
      lines.push('');
      lines.push('        return ()');
    }

    lines.push('    }');

    return lines.join('\n');
  }

  private generateErrorEnum(apiName: string): string {
    const lines: string[] = [];

    lines.push(`/// Errors that can occur when using ${apiName}APIClient`);
    lines.push(`public enum ${apiName}APIError: Error {`);
    lines.push('    case invalidURL');
    lines.push('    case invalidResponse');
    lines.push('    case httpError(Int)');
    lines.push('    case decodingError(Error)');
    lines.push('}');

    return lines.join('\n');
  }

  private getResponseType(endpoint: ParsedEndpoint): string {
    const successResponse = endpoint.responses.find(r => r.statusCode.startsWith('2'));
    if (successResponse && successResponse.type) {
      const isArray = successResponse.type.startsWith('array');
      return this.mapToSwiftType(successResponse.type, isArray);
    }
    return 'Void';
  }

  private getErrorTypeName(endpoint: ParsedEndpoint): string {
    // Extract the API name from operationId
    // For now, we'll use a simple approach
    return endpoint.tags?.[0] || 'API';
  }

  private mapToSwiftType(type: string, isArray: boolean = false): string {
    let baseType = this.getBaseSwiftType(type);

    if (isArray) {
      baseType = `[${baseType}]`;
    }

    return baseType;
  }

  private getBaseSwiftType(type: string): string {
    switch (type) {
      case 'string':
        return 'String';
      case 'integer':
        return 'Int';
      case 'number':
        return 'Double';
      case 'boolean':
        return 'Bool';
      case 'object':
        return '[String: Any]';
      case 'array':
        return '[Any]';
      default:
        // Assume it's a model reference
        return type;
    }
  }
}
