import { ParsedAPI, ParsedEndpoint, ParsedParameter } from './openapi-types';

export class KotlinAPIClientGenerator {
  generate(api: ParsedAPI, sourceFile: string): string {
    const lines: string[] = [];

    // Header
    lines.push(this.createHeader(sourceFile));
    lines.push('import kotlinx.coroutines.Dispatchers');
    lines.push('import kotlinx.coroutines.withContext');
    lines.push('import kotlinx.serialization.json.Json');
    lines.push('import kotlinx.serialization.encodeToString');
    lines.push('import kotlinx.serialization.decodeFromString');
    lines.push('import java.net.HttpURLConnection');
    lines.push('import java.net.URL');
    lines.push('');

    // API Client Interface
    if (api.description) {
      lines.push(`/**`);
      lines.push(` * ${api.description}`);
      lines.push(` */`);
    }
    lines.push(`interface ${api.name}APIClient {`);

    // Method declarations
    api.endpoints.forEach(endpoint => {
      lines.push(this.generateMethodSignature(endpoint));
      lines.push('');
    });

    lines.push('}');
    lines.push('');

    // Default implementation
    lines.push(`/**`);
    lines.push(` * Default implementation of ${api.name}APIClient`);
    lines.push(` */`);
    lines.push(`class Default${api.name}APIClient(`);
    lines.push('    private val baseUrl: String,');
    lines.push('    private val json: Json = Json { ignoreUnknownKeys = true }');
    lines.push(`): ${api.name}APIClient {`);
    lines.push('');

    // Method implementations
    api.endpoints.forEach(endpoint => {
      lines.push(this.generateMethodImplementation(endpoint));
      lines.push('');
    });

    // Helper methods
    lines.push(this.generateHelperMethods());

    lines.push('}');
    lines.push('');

    // Exception classes
    lines.push(this.generateExceptionClasses(api.name));

    return lines.join('\n');
  }

  private createHeader(sourceFile: string): string {
    const timestamp = new Date().toISOString().split('T')[0];
    return [
      `// Generated by cuppa-cli from ${sourceFile}`,
      `// Generation date: ${timestamp}`,
      `// DO NOT EDIT MANUALLY - Changes will be overwritten`,
      '',
    ].join('\n');
  }

  private generateMethodSignature(endpoint: ParsedEndpoint): string {
    const lines: string[] = [];

    // Documentation
    if (endpoint.summary || endpoint.description) {
      lines.push('    /**');
      if (endpoint.summary) {
        lines.push(`     * ${endpoint.summary}`);
      }
      if (endpoint.description) {
        lines.push(`     * ${endpoint.description}`);
      }

      // Parameters documentation
      const allParams = [...endpoint.pathParams, ...endpoint.queryParams];
      if (endpoint.requestBody) {
        allParams.push({
          name: 'body',
          type: endpoint.requestBody.type,
          description: endpoint.requestBody.description,
          required: endpoint.requestBody.required,
          isArray: false,
        });
      }

      allParams.forEach(param => {
        const desc = param.description || param.name;
        lines.push(`     * @param ${param.name} ${desc}`);
      });

      lines.push('     */');
    }

    // Method signature
    const params = this.buildParameters(endpoint);
    const responseType = this.getResponseType(endpoint);
    lines.push(`    suspend fun ${endpoint.operationId}(${params.join(', ')}): ${responseType}`);

    return lines.join('\n');
  }

  private generateMethodImplementation(endpoint: ParsedEndpoint): string {
    const lines: string[] = [];

    // Method signature
    const params = this.buildParameters(endpoint);
    const responseType = this.getResponseType(endpoint);
    lines.push(`    override suspend fun ${endpoint.operationId}(${params.join(', ')}): ${responseType} =`);
    lines.push('        withContext(Dispatchers.IO) {');

    // Build URL
    lines.push('            // Build URL');
    let urlPath = endpoint.path;
    endpoint.pathParams.forEach(param => {
      urlPath = urlPath.replace(`{${param.name}}`, `$${param.name}`);
    });
    lines.push(`            var urlString = "$baseUrl${urlPath}"`);

    // Add query parameters
    if (endpoint.queryParams.length > 0) {
      lines.push('');
      lines.push('            // Add query parameters');
      lines.push('            val queryParams = mutableListOf<String>()');
      endpoint.queryParams.forEach(param => {
        if (param.required) {
          lines.push(`            queryParams.add("${param.name}=$${param.name}")`);
        } else {
          lines.push(`            ${param.name}?.let { queryParams.add("${param.name}=$it") }`);
        }
      });
      lines.push('            if (queryParams.isNotEmpty()) {');
      lines.push('                urlString += "?" + queryParams.joinToString("&")');
      lines.push('            }');
    }

    lines.push('');
    lines.push('            // Create connection');
    lines.push('            val url = URL(urlString)');
    lines.push('            val connection = url.openConnection() as HttpURLConnection');
    lines.push('');
    lines.push('            try {');
    lines.push(`                connection.requestMethod = "${endpoint.method}"`);
    lines.push('                connection.setRequestProperty("Content-Type", "application/json")');
    lines.push('                connection.setRequestProperty("Accept", "application/json")');

    // Add request body
    if (endpoint.requestBody) {
      lines.push('');
      lines.push('                // Send request body');
      lines.push('                connection.doOutput = true');
      lines.push('                val jsonBody = json.encodeToString(body)');
      lines.push('                connection.outputStream.use { it.write(jsonBody.toByteArray()) }');
    }

    lines.push('');
    lines.push('                // Execute request');
    lines.push('                val responseCode = connection.responseCode');
    lines.push('');
    lines.push('                if (responseCode in 200..299) {');

    // Decode response
    const successResponse = endpoint.responses.find(r => r.statusCode.startsWith('2'));
    if (successResponse && successResponse.type) {
      lines.push('                    // Read and decode response');
      lines.push('                    val responseBody = connection.inputStream.bufferedReader().use { it.readText() }');
      lines.push(`                    json.decodeFromString<${responseType}>(responseBody)`);
    } else {
      lines.push('                    Unit');
    }

    lines.push('                } else {');
    lines.push('                    val errorBody = connection.errorStream?.bufferedReader()?.use { it.readText() } ?: ""');
    lines.push('                    throw APIException.HttpException(responseCode, errorBody)');
    lines.push('                }');
    lines.push('            } finally {');
    lines.push('                connection.disconnect()');
    lines.push('            }');
    lines.push('        }');

    return lines.join('\n');
  }

  private generateHelperMethods(): string {
    return [
      '    private fun buildQueryString(params: Map<String, String?>): String {',
      '        return params',
      '            .filterValues { it != null }',
      '            .map { "${it.key}=${it.value}" }',
      '            .joinToString("&")',
      '    }',
    ].join('\n');
  }

  private generateExceptionClasses(apiName: string): string {
    const lines: string[] = [];

    lines.push(`/**`);
    lines.push(` * Exceptions that can occur when using ${apiName}APIClient`);
    lines.push(` */`);
    lines.push('sealed class APIException(message: String) : Exception(message) {');
    lines.push('    class HttpException(val code: Int, val body: String) : APIException("HTTP $code: $body")');
    lines.push('    class NetworkException(cause: Throwable) : APIException("Network error: ${cause.message}")');
    lines.push('    class SerializationException(cause: Throwable) : APIException("Serialization error: ${cause.message}")');
    lines.push('}');

    return lines.join('\n');
  }

  private buildParameters(endpoint: ParsedEndpoint): string[] {
    const allParams = [...endpoint.pathParams, ...endpoint.queryParams];
    if (endpoint.requestBody) {
      allParams.push({
        name: 'body',
        type: endpoint.requestBody.type,
        description: endpoint.requestBody.description,
        required: endpoint.requestBody.required,
        isArray: false,
      });
    }

    return allParams.map(p => {
      const type = this.mapToKotlinType(p.type, p.isArray);
      const nullable = p.required ? '' : '?';
      return `${p.name}: ${type}${nullable}`;
    });
  }

  private getResponseType(endpoint: ParsedEndpoint): string {
    const successResponse = endpoint.responses.find(r => r.statusCode.startsWith('2'));
    if (successResponse && successResponse.type) {
      const isArray = successResponse.type.startsWith('array');
      return this.mapToKotlinType(successResponse.type, isArray);
    }
    return 'Unit';
  }

  private mapToKotlinType(type: string, isArray: boolean = false): string {
    let baseType = this.getBaseKotlinType(type);

    if (isArray) {
      baseType = `List<${baseType}>`;
    }

    return baseType;
  }

  private getBaseKotlinType(type: string): string {
    switch (type) {
      case 'string':
        return 'String';
      case 'integer':
        return 'Int';
      case 'number':
        return 'Double';
      case 'boolean':
        return 'Boolean';
      case 'object':
        return 'Map<String, Any>';
      case 'array':
        return 'List<Any>';
      default:
        // Assume it's a model reference
        return type;
    }
  }
}
